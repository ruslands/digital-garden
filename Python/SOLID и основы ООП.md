## SOLID

**SOLID** — это набор принципов (рекомендаций), которые призваны помочь в создании качественного объектно-ориентированного кода приложения.

### The Single Responsibility Principle (SRP) — Принцип единственной ответственности
Каждый класс должен решать только одну конкретную задачу. Не следует создавать огромные классы-гиганты, решающие множество слабосвязанных или несвязанных задач. Ограниченная область ответственности упрощает модернизацию кода, повышает его читаемость, снижает сложность и увеличивает возможность повторного использования. Следование этому принципу улучшает код по всем параметрам.

### The Open Closed Principle (OCP) — Принцип открытости/закрытости
Сущности должны быть открыты для расширения, но закрыты для модификации. Это означает, что функционал классов можно расширять через наследование, но не изменять их исходное поведение и структуру. Такой подход предотвращает конфликты между классами и сохраняет старое поведение, добавляя новое.

### The Liskov Substitution Principle (LSP) — Принцип подстановки Барбары Лисков
Наследующий класс должен дополнять, а не изменять поведение базового класса. При подстановке наследника вместо родителя поведение программы должно оставаться неизменным. Наследник расширяет функционал, а не переопределяет его кардинально.

### The Interface Segregation Principle (ISP) — Принцип разделения интерфейса
Клиенты не должны зависеть от методов, которые они не используют. Лучше иметь много специализированных интерфейсов, чем один общего назначения. Компактные интерфейсы предотвращают появление ненужного кода, который пришлось бы реализовывать из-за избыточных методов.

### The Dependency Inversion Principle (DIP) — Принцип инверсии зависимости
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций, а абстракции — не от деталей. Детали должны зависеть от абстракций. Это означает:
1. Предки не зависят от потомков, иерархия должна быть четкой.
2. Связь между классами осуществляется через интерфейсы.
3. Интерфейсы и абстрактные классы содержат только сигнатуры методов, без реализаций.
4. Конкретные классы реализуют интерфейсы.  
Такой подход упрощает замену реализаций без изменения основного кода.

---

## Основы ООП

### Абстракция
Абстракция — это выделение существенных для задачи деталей и игнорирование несущественных. В ООП это означает, что для каждого объекта задаётся минимальный набор методов, полей и описаний, достаточный для решения задачи. Чем меньше лишних характеристик, тем лучше абстракция, но ключевые убирать нельзя.

### Наследование (Inheritance)
Наследование в ООП — это механизм, позволяющий классам (подклассам) базироваться на других классах (суперклассах). Также их называют родительскими и дочерними классами. Это способность объекта или класса использовать свойства и поведение другого объекта или класса.

### Полиморфизм
Полиморфизм — это возможность обрабатывать разные типы данных (принадлежащие разным классам) с помощью одной и той же функции или метода. Имя метода остаётся одинаковым, но его реализация и результаты зависят от класса. Полиморфизм отражает множество форм одного имени метода.

### Инкапсуляция и сокрытие
Инкапсуляция — это объединение данных и методов для их обработки в одном классе. В Python инкапсуляция реализуется на уровне классов и объектов.  
Сокрытие в Python имитируется через соглашение: атрибуты с двумя подчеркиваниями перед именем (`__attribute`) предназначены только для внутреннего использования. Хорошая практика — скрывать все поля объектов, предоставляя доступ к ним только через методы (геттеры и сеттеры), чтобы защитить данные от прямого изменения.

### Агрегация и композиция (Composition)
- **Агрегация** — это подход, при котором класс-контейнер включает объекты других классов, создавая их автоматически при своём создании.  
- **Композиция** — частный случай агрегации, когда класс-агрегатор формирует целое из частей, управляя их жизненным циклом.  
Композицию не следует путать с наследованием: наследование отражает "похожесть" (is-a), а композиция — "состав" (has-a).

---

## Inheritance vs Composition

В объектно-ориентированном программировании наследование и композиция — это два способа создания отношений между классами. Каждый имеет свои плюсы и минусы, и выбор зависит от задачи и целей проектирования.

### 1. Наследование (Inheritance)
Наследование позволяет подклассу унаследовать свойства и поведение суперкласса, создавая иерархическую связь и моделируя отношение "является" (is-a). Например, `Car` наследует от `Vehicle`.

#### Плюсы:
- **Повторное использование кода**: Подклассы используют свойства и методы суперкласса, избегая дублирования.
- **Полиморфизм**: Подклассы могут заменять суперкласс, обеспечивая гибкость.

#### Минусы:
- **Жёсткая связь**: Наследование создаёт сильную зависимость между классами, усложняя поддержку.
- **Проблема хрупкого базового класса**: Изменения в базовом классе могут сломать подклассы.
- **Ограниченная гибкость**: Иерархия фиксирована и не всегда подходит.

### 2. Композиция (Composition)
Композиция — это включение объектов других классов в класс-контейнер, создавая отношение "имеет" (has-a). Например, `Car` содержит объект `Engine`.

#### Плюсы:
- **Гибкость**: Легче комбинировать поведение и адаптироваться к изменениям.
- **Слабая связь**: Классы более независимы, что упрощает поддержку.
- **Лёгкость изменения**: Поведение можно менять, заменяя составные объекты.

#### Минусы:
- **Увеличение сложности**: Больше объектов — сложнее код.
- **Дополнительный код**: Нужно писать делегирование функциональности.

### Итог
Нет универсального "лучшего" подхода. Композиция часто предпочтительнее из-за гибкости и модульности, избегая проблем наследования. Однако наследование полезно, когда есть явное отношение "является" и требуется повторное использование кода. В хорошей системе ООП обычно сочетаются оба подхода.